[{"_id":{"$objectID":"59c268574677422190abd672"},"code":"const required = [\n  {\n    validatorType: \"REQUIRED\"\n  }\n];\n//debugger;\nthis.libs.getProcessors(\n  this.entityRepo,\n  [\"GET_SESSIONS\", \"GET_YearOfStudy_5\", \"GET_MODEOFSTUDY\", \"GET_SCHOOLPROGRAMME\", \"GET_PaymentType_8\", \"GET_Semester_3\"],\n  (er, processors) => {\n    if (er) return callback(er);\n\n    this.entityRepo.get(\n      \"StudentType\",\n      {\n        domain: this.args.$user.domain\n      },\n      (er, studentTypes) => {\n        if (er) return callback(er);\n\n        let elements = [],\n          e = this.libs.createElement.bind(this),\n          c = this.constants;\n\n        this.entityRepo.get(\n          \"FeePurpose\",\n          {\n            domain: this.args.$user.domain\n          },\n          (er, feePurposes) => {\n            if (er) return callback(er);\n            const getSession = () =>\n              e(\n                \"session\",\n                \"Session\",\n                \"\",\n                c.ELEMENTTYPE.SELECT,\n                {\n                  type: \"PROCESSOR\",\n                  config: {\n                    value: processors.GET_SESSIONS\n                  }\n                },\n                required\n              );\n            let items = feePurposes.map(f => {\n              let _elements = [];\n              if (/school\\s*fees/gi.test(f.name) || /acceptance/gi.test(f.name)) {\n                _elements.push(\n                  e(\n                    \"studentType\",\n                    \"Student Type\",\n                    \"\",\n                    c.ELEMENTTYPE.SELECTSET,\n                    {\n                      path: \"config\",\n                      items: studentTypes.map(x => ({\n                        displayLabel: x.name,\n                        id: x._id.toString(),\n                        elements: getFor(x, processors)\n                      }))\n                    },\n                    required\n                  )\n                );\n\n                _elements.push(getSession());\n              }\n\n              if (/result/gi.test(f.name)) {\n                _elements.push(\n                  getSession(),\n                  e(\n                    \"semester\",\n                    \"Semester\",\n                    \"\",\n                    c.ELEMENTTYPE.SELECT,\n                    {\n                      type: \"PROCESSOR\",\n                      config: {\n                        value: processors.GET_Semester_3\n                      }\n                    },\n                    required\n                  )\n                );\n              }\n\n              return {\n                id: f._id,\n                displayLabel: f.name,\n                elements: _elements\n              };\n            });\n\n            let feePurpose = e(\"feePurpose\", \"Fee Purpose\", \"\", c.ELEMENTTYPE.SELECTSET, {\n              path: \"criteria\",\n              items\n            });\n            elements.push(feePurpose);\n\n            callback(null, elements);\n          }\n        );\n      }\n    );\n  }\n);\n\nconst getFor = (x, processors) => {\n  let paymentType = this.libs.createElement(\n      \"paymentType\",\n      \"Payment Type\",\n      \"\",\n      this.constants.ELEMENTTYPE.SELECT,\n      {\n        type: \"PROCESSOR\",\n        config: {\n          value: processors.GET_PaymentType_8,\n          customArgs: JSON.stringify({\n            query: {\n              group: x.group\n            }\n          })\n        }\n      },\n      required\n    ),\n    yearOfStudy = this.libs.createElement(\n      \"yearOfStudy\",\n      \"Year of Study\",\n      \"\",\n      this.constants.ELEMENTTYPE.SELECT,\n      {\n        type: \"PROCESSOR\",\n        config: {\n          customArgs: JSON.stringify({ query: { group: \"UNDERGRADUATE\" } }),\n          value: processors.GET_YearOfStudy_5\n        }\n      },\n      required\n    );\n  if (/pg/i.test(x.group)) {\n    yearOfStudy.args.config.customArgs = JSON.stringify({ query: { group: \"PG\" } });\n    return [\n      yearOfStudy,\n      paymentType,\n      this.libs.createElement(\n        \"programmeOption\",\n        \"Programme Options\",\n        \"\",\n        this.constants.ELEMENTTYPE.SELECT,\n        {\n          type: \"PROCESSOR\",\n          config: {\n            value: processors.GET_SCHOOLPROGRAMME,\n            customArgs: JSON.stringify({\n              query: {\n                group: x.group\n              }\n            })\n          }\n        },\n        required\n      ),\n      this.libs.createElement(\n        \"forStaff\",\n        \"Staff\",\n        \"\",\n        this.constants.ELEMENTTYPE.INPUT,\n        {\n          type: this.constants.INPUTTYPE.CHECKBOX\n        },\n        required\n      ),\n      this.libs.createElement(\n        \"modeOfStudy\",\n        \"Mode of Study\",\n        \"\",\n        this.constants.ELEMENTTYPE.SELECT,\n        {\n          type: \"PROCESSOR\",\n          config: {\n            value: processors.GET_MODEOFSTUDY\n          }\n        },\n        required\n      )\n    ];\n  }\n  if (/undergraduate/i.test(x.group)) {\n    return [\n      paymentType,\n      yearOfStudy,\n      this.libs.createElement(\"yearOfEntry\", \"Year of Entry\", \"\", this.constants.ELEMENTTYPE.SELECT, {\n        type: \"PROCESSOR\",\n        config: {\n          value: processors.GET_YearOfStudy_5\n        }\n      })\n    ];\n  }\n\n  return [];\n};\n","title":"Get Fee Assignment UI","requiresIdentity":true,"__v":0,"standalone":true},{"_id":{"$objectID":"59c5aa418870a83308edda38"},"code":"/*jshint esversion:6 */\r\n\r\nconst run = () => {\r\n  let inf = this.entityRepo.infrastructure();\r\n  if (!inf || !inf.userManager) return callback(new Error(\"Infrastructure is not available\"));\r\n\r\n  if (!inf.userManager.inRole(this.args.$domain.config.studentRole, this.args.$user)) return callback(new Error(\"User is not a student\"));\r\n\r\n  let domain = this.args.$domain;\r\n\r\n  this.entityRepo.get(\r\n    domain.config.studentClass,\r\n    {\r\n      userId: this.args.$user._id\r\n    },\r\n    {\r\n      one: true\r\n    },\r\n    (er, student) => {\r\n      this.entityRepo.get(\r\n        \"FeePurpose\",\r\n        {\r\n          _id: this.args.feePurpose\r\n        },\r\n        {\r\n          one: true\r\n        },\r\n        (er, feePurpose) => {\r\n          if (er) return callback(er);\r\n          if (!feePurpose) return callback(new Error(\"Could not find that fee type\"));\r\n\r\n          let criteria = {\r\n              feePurpose: this.args.feePurpose\r\n            },\r\n            isAcceptance = /acceptance/i.test(feePurpose.name),\r\n            isHostel = /hostel/i.test(feePurpose.name),\r\n            isResult = /result/gi.test(feePurpose.name),\r\n            isSchoolFees = /school/i.test(feePurpose.name);\r\n          if (isSchoolFees) {\r\n            this.debug(\"is school fees payment\");\r\n            Object.assign(criteria, {\r\n              [\"criteria.config.yearOfStudy\"]: this.args.criteria.yearOfStudy,\r\n              [\"criteria.session\"]: this.args.criteria.session,\r\n              [\"criteria.department\"]: student.programmeDetails.department,\r\n              [\"criteria.modeOfStudy\"]: student.programmeDetails.modeOfStudy\r\n            });\r\n            if (student.studentType.group == \"PG\") {\r\n              criteria[\"criteria.programmeOption\"] = student.programmeDetails.programmeOption;\r\n              criteria[\"criteria.isStaff\"] = !!student.isStaff;\r\n            }\r\n          }\r\n\r\n          if (isResult) {\r\n            this.debug(\"result payment\");\r\n            Object.assign(criteria, {\r\n              [\"criteria.session\"]: this.args.criteria.session,\r\n              [\"criteria.semester\"]: this.args.criteria.semester\r\n            });\r\n          }\r\n          const process = (fee, fn = callback) => {\r\n            var config = this.libs.flattenByNamespace(\"remita\", domain.config);\r\n            return this.libs.generateRemitaRRR.call(\r\n              this,\r\n              {\r\n                splitFee: !!feePurpose.hasCommission,\r\n                merchant: Object.assign(config, {\r\n                  feeAccount: this.libs.flattenByNamespace(\"feeAccount\", domain.config)\r\n                }),\r\n                data: {\r\n                  feeId: fee._id,\r\n                  userId: this.args.$user._id,\r\n                  studentId: student._id,\r\n                  payerName: `${student.personalDetails.firstName} ${student.personalDetails.middlename} ${student.personalDetails\r\n                    .surname}`,\r\n                  payerEmail: student.contactDetails && student.contactDetails.email\r\n                },\r\n                amount: fee.fee\r\n              },\r\n              (er, { RRR } = {}) => {\r\n                if (er || !RRR)\r\n                  return this.debug(\"error occurred while generating RRR\"), fn(er || new Error(\"Remita did not return RRR, please retry\"));\r\n\r\n                this.entityRepo.getProcess(\r\n                  {\r\n                    uid: \"IWEBVIEW\"\r\n                  },\r\n                  {\r\n                    one: true\r\n                  },\r\n                  (er, process) => {\r\n                    let warning = null;\r\n                    if (er || !process)\r\n                      this.debug(\"could not locate webview process\"),\r\n                        (warning = (process && \"Unknown Error\") || \"Couldn't locate pay now view\");\r\n                    let url = `${config.payUrl}?RRR=${RRR}&domain=${domain._id}`;\r\n                    fn(null, {\r\n                      message: warning || \"Successful\",\r\n                      info: `Successfully generated Invoice Number ${RRR} , please use this invoice number to make payment at any bank branch nationwide`,\r\n                      payHere:\r\n                        (!warning && `${process && process._id}|url=${encodeURIComponent(url)}|title=Fees`) ||\r\n                        \"cannot pay now , retry later....\"\r\n                    });\r\n                  }\r\n                );\r\n              }\r\n            );\r\n          };\r\n\r\n          if (isHostel) {\r\n            let hostelAPI = new this.libs.HostelAPI(this.entityRepo.infrastructure().request, this.args.$requestContext.authorization);\r\n            hostelAPI.createABooking(\r\n              Object.assign({}, this.args.criteria, { session: student.programmeDetails.session, domain: this.args.$user.domain }),\r\n              (er, { booking_id } = {}) => {\r\n                if (er) return callback(er);\r\n\r\n                return process({ fee: this.args.criteria.fee, _id: booking_id }, (err, result) => {\r\n                  if (err) {\r\n                    if (booking_id)\r\n                      return hostelAPI.deleteABooking(booking_id, er => {\r\n                        return callback(err);\r\n                      });\r\n\r\n                    return callback(err);\r\n                  }\r\n\r\n                  return callback(null, result);\r\n                });\r\n              }\r\n            );\r\n            return;\r\n          }\r\n\r\n          this.entityRepo.get(\r\n            \"Fee\",\r\n            criteria,\r\n            {\r\n              one: true\r\n            },\r\n            (er, fee) => {\r\n              if (er || !fee)\r\n                return (\r\n                  this.debug(\"error occurred while fetching fee\"),\r\n                  callback(er || new Error(\"There has been no fees setup for you, for that session\"))\r\n                );\r\n              this.debug(\"fetched fee\");\r\n              this.debug(fee);\r\n              this.debug(feePurpose);\r\n              if (isSchoolFees || isAcceptance || isResult) {\r\n                return process(fee);\r\n              }\r\n\r\n              return callback(new Error(\"We dont know how to process that fee type\"));\r\n            }\r\n          );\r\n        }\r\n      );\r\n    }\r\n  );\r\n};\r\n\r\nrun();\r\n","title":"Get fees config and generate RRR","requiresIdentity":true,"__v":0,"standalone":false},{"_id":{"$objectID":"59c90090ff62ab3360746640"},"code":"const getElementsFor = (elem, options, fn) => {\r\n  if (/school\\s*fees/i.test(elem.name)) {\r\n    return setImmediate(fn, null, [\r\n      this.libs.createElement(\"yearOfStudy\", \"Level\", \"\", this.constants.ELEMENTTYPE.SELECT, {\r\n        type: \"PROCESSOR\",\r\n        config: {\r\n          value: options.GET_YearOfStudy_5\r\n        }\r\n      }),\r\n      this.libs.createElement(\"session\", \"Session\", \"\", this.constants.ELEMENTTYPE.SELECT, {\r\n        type: \"PROCESSOR\",\r\n        config: {\r\n          value: options.GET_SESSIONS\r\n        }\r\n      })\r\n    ]);\r\n  }\r\n  if (/hostel/gi.test(elem.name)) {\r\n    return setImmediate(fn, null, [\r\n      this.libs.createElement(\r\n        \"hostel\",\r\n        \"\",\r\n        \"Find out what hostels are available...\",\r\n        this.constants.ELEMENTTYPE.SELECTSET,\r\n        {\r\n          processor: options.GET_ELIGIBLE_HOSTELS\r\n        },\r\n        [{ validatorType: this.constants.VALIDATORTYPE.REQUIRED }]\r\n      )\r\n    ]);\r\n  }\r\n  if (/result/gi.test(elem.name)) {\r\n    return setImmediate(fn, null, [\r\n      this.libs.createElement(\"session\", \"Session\", \"\", this.constants.ELEMENTTYPE.SELECT, {\r\n        type: \"PROCESSOR\",\r\n        config: {\r\n          value: options.GET_SESSIONS\r\n        }\r\n      }),\r\n      this.libs.createElement(\"semester\", \"Semester\", \"\", this.constants.ELEMENTTYPE.SELECT, {\r\n        type: \"PROCESSOR\",\r\n        config: {\r\n          value: options.GET_Semester_3\r\n        }\r\n      })\r\n    ]);\r\n  }\r\n  return setImmediate(fn, null, []);\r\n};\r\n\r\nlet query = { domain: this.args.$user.domain };\r\nif (this.args.group) {\r\n  query.group = new RegExp(this.args.group, \"i\");\r\n}\r\nthis.debug(query);\r\nthis.entityRepo.get(\"FeePurpose\", query, (er, feePurposes) => {\r\n  if (er) return callback(er);\r\n\r\n  this.libs.getProcessors(this.entityRepo, [\"GET_YearOfStudy_5\", \"GET_SESSIONS\", \"GET_ELIGIBLE_HOSTELS\", \"GET_Semester_3\"], (er, processors) => {\r\n    if (er) return callback(er);\r\n\r\n    let tasks = [];\r\n    feePurposes.forEach(x => {\r\n      tasks.push(getElementsFor.bind(this, x, processors));\r\n    });\r\n\r\n    this.async.parallel(tasks, (er, results) => {\r\n      if (er) return callback(er);\r\n\r\n      callback(\r\n        null,\r\n        results.map((item, index) => {\r\n          return {\r\n            id: feePurposes[index]._id,\r\n            displayLabel: feePurposes[index].name,\r\n            elements: item\r\n          };\r\n        })\r\n      );\r\n    });\r\n  });\r\n});\r\n","title":"Get Fee Purpose Options for Payment","requiresIdentity":true,"__v":0,"standalone":true},{"_id":{"$objectID":"5ae6f5aeed96bc603898dc96"},"code":"this.args.entity.domain = this.args.$user.domain;\nthis.debug(\"creating new assignment\");\nthis.debug(this.args);\nlet query = {\n  course: this.args.entity.courseId,\n  department: this.args.entity.department,\n  lecturer: this.args.entity.lecturer,\n  session: this.args.entity.session,\n  domain: this.args.$user.domain,\n  semester: this.args.entity.semester,\n  studentType: this.args.entity.studentType,\n  campus: this.args.entity.campus\n};\nthis.debug(query);\n\nthis.entityRepo.get(\"CourseLecturerAssignment\", query, (error, exists) => {\n  if (error) return callback(error);\n  else if (exists.length)\n    return callback(new Error(\"An entry with that configuration already exists please edit the course to lecturer assignment\"));\n  else this.entityRepo.create(\"CourseLecturerAssignment\", query, callback);\n});\n","title":"Assign course to lecturer","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5ae7165ded96bc603898dc9b"},"code":"this.args.depth = true;\r\nthis.$checkDomain = true;\r\nconst objectId = prop => {\r\n  if (this.args.query && this.args.query[prop])\r\n    this.args.query[prop] = {\r\n      isObjectID: true,\r\n      value: this.args.query[prop]\r\n    };\r\n};\r\nconst run = {\r\n  extended: () => {\r\n    if (!this.args.query || !this.args.query.studentType)\r\n      return callback(null, {\r\n        items: [],\r\n        total: 0\r\n      });\r\n    objectId(\"studentType\");\r\n    objectId(\"department\");\r\n    objectId(\"semester\");\r\n    objectId(\"session\");\r\n    objectId(\"campus\");\r\n    // if(this.args.isHod) {\r\n    //     this.args.query[\"isHod\"] = this.args.isHod;\r\n    //     objectId(\"isHod\");\r\n    // }\r\n    this.debug(this.args);\r\n\r\n    let extra = {\r\n      department: this.args.query[\"department\"].value,\r\n      semester: this.args.query[\"semester\"].value,\r\n      session: this.args.query[\"session\"].value,\r\n      studentType: this.args.query[\"studentType\"].value,\r\n      campus: this.args.query[\"campus\"].value\r\n    };\r\n\r\n    if (this.args.query && this.args.query[\"campus\"]) delete this.args.query[\"campus\"];\r\n\r\n    this.libs.getEntity.call(\r\n      this,\r\n      \"CourseAssignment\",\r\n      \"\",\r\n      x => {\r\n        return Object.assign(extra, {\r\n          _id: x._id,\r\n          courseType: x.courseType.name,\r\n          courseName: x.course.name,\r\n          courseUnit: x.courseUnit,\r\n          courseCode: x.course.code,\r\n          courseId: x.course._id\r\n        });\r\n      },\r\n      (error, result) => {\r\n        if (error || !result) callback(new Error(\"could not find course assignment for the criteria\"));\r\n\r\n        if (!result.items) callback(null, result);\r\n        else {\r\n          result.items.forEach((item, index) => {\r\n            this.entityRepo.get(\r\n              \"CourseLecturerAssignment\",\r\n              {\r\n                course: item.courseId\r\n              },\r\n              {\r\n                one: true\r\n              },\r\n              (error, assignment) => {\r\n                if (assignment) {\r\n                  result.items[index] = Object.assign(\r\n                    {\r\n                      lecturer: assignment.lecturer\r\n                    },\r\n                    item\r\n                  );\r\n                }\r\n                if (index == result.items.length - 1) {\r\n                  callback(null, result);\r\n                }\r\n              }\r\n            );\r\n          });\r\n        }\r\n      }\r\n    );\r\n  },\r\n  stripped: () => {\r\n    if (!this.args.query)\r\n      return callback(null, {\r\n        items: [],\r\n        total: 0\r\n      });\r\n\r\n    this.entityRepo.get(\r\n      \"Staff\",\r\n      {\r\n        userId: this.args.$user._id\r\n      },\r\n      {\r\n        one: true\r\n      },\r\n      (er, staff) => {\r\n        if (er) return callback(er);\r\n        if (!staff) return callback(new Error(\"You have to be a staff to perform this operation\"));\r\n        this.args.query[\"department\"] = staff.department.toString();\r\n        this.args.query[\"lecturer\"] = staff._id.toString();\r\n        let extra = {\r\n          semester: this.args.query[\"semester\"],\r\n          session: this.args.query[\"session\"],\r\n          department: this.args.query[\"department\"]\r\n        };\r\n\r\n        objectId(\"semester\");\r\n        objectId(\"session\");\r\n        objectId(\"department\");\r\n        objectId(\"lecturer\");\r\n\r\n        this.debug(this.args.query);\r\n\r\n        this.libs.getEntity.call(\r\n          this,\r\n          \"CourseLecturerAssignment\",\r\n          \"\",\r\n          x => {\r\n            return Object.assign(extra, {\r\n              _id: x._id,\r\n              courseName: x.course.name,\r\n              courseCode: x.course.code,\r\n              courseId: x.course._id\r\n            });\r\n          },\r\n          (error, result) => {\r\n            this.debug(result);\r\n            if (error || !result || (result && result.items.length < 1))\r\n              callback(new Error(\"could not find course assignment for the criteria\"));\r\n\r\n            callback(null, result);\r\n          }\r\n        );\r\n      }\r\n    );\r\n  }\r\n};\r\n\r\nif (this.args.query && this.args.query[\"department\"]) run[\"extended\"]();\r\nelse run[\"stripped\"]();\r\n","title":"Get Course Lecturer assignment","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aeae84ab8ff605b883f098b"},"code":"let inf = this.entityRepo.infrastructure(),\n  fileUpload = inf.fileUpload,\n  fileParser = inf.fileParser,\n  threadPool = inf.threadPool;\nthis.debug(\"=============================================================\");\nthis.debug(this.args);\nthis.libs.parseObjectIds.call(this, this.args);\n\nlet uploadResult = () => {\n  this.entityRepo.get(\"Staff\", { userId: this.args.$user._id }, { one: true }, (error, staff) => {\n    if (error || !staff) callback(new Error(\"No staff details could be found\"));\n\n    let args = this.args.entity,\n      contx = {\n        semester: args.semester,\n        session: args.session,\n        department: args.department,\n        course: args.courseId,\n        lecturer: staff._id\n      };\n    this.libs.convertFileAndSave(\n      this.args.$domain.config.resultClass,\n      args.file,\n      contx,\n      [\"regNo\", \"fullName\", \"examScore\", \"courseCode\", \"examDate\"],\n      null,\n      fileUpload,\n      fileParser,\n      threadPool,\n      this.entityRepo,\n      this.args.$user,\n      callback\n    );\n  });\n};\n\nif (!fileUpload || !fileParser || !threadPool) {\n  this.debug(`something is undefined ...fileUpload:${!!fileUpload}, fileParser:${!!fileParser}, threadPool:${!!threadPool}`),\n    callback(new Error(\"Infrastructure has a problem\"));\n} else if (!this.args.entity && !this.args.entity.file) {\n  this.debug(\"user didnt upload any file\");\n  callback(new Error(\"Missing Result file. Try uploading the file again, if this was already done.\"));\n} else uploadResult();\n","title":"upload student results","uid":"UPLOAD_STUDENT_RESULT","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aec2cf2f941ca2264648075"},"code":"if (this.args.query && this.args.query.invoiceNumber) {\r\n  this.libs.getStudent.call(\r\n    this,\r\n    {\r\n      userId: this.args.$user._id\r\n    },\r\n    (er, student) => {\r\n      if (er) cb(er);\r\n      if (!student)\r\n        cb(new Error(\"Are you sure you are a student?, because we could not find your details. Kindly contact your school authorities\"));\r\n\r\n      let merchantConfig = this.libs.flattenByNamespace(\"remita\", this.args.$domain.config);\r\n      this.debug(merchantConfig);\r\n      this.libs.confirmRemitaPayment.call(this, this.args.query.invoiceNumber, merchantConfig, this.args.$domain, (er, status) => {\r\n        if (er) return callback(er);\r\n\r\n        if (!status)\r\n          return callback(new Error(\"You have been unable to confirm payment has been made against \" + this.args.query.invoiceNumber));\r\n\r\n        this.debug(\"payment successfully confirmed\");\r\n\r\n        this.entityRepo.get(\r\n          this.args.$domain.config.resultClass,\r\n          { session: this.args.query.session, semester: this.args.query.semester, approved: true, regNo: student.regNo || student.refNo },\r\n          (error, result) => {\r\n            if (error) callback(error);\r\n            else if (result.length < 1) callback(null, { items: [], message: \"Result has not been uploaded\" });\r\n            else {\r\n              this.debug(result);\r\n              callback(null, { items: result });\r\n            }\r\n          }\r\n        );\r\n      });\r\n    }\r\n  );\r\n} else {\r\n  callback(null, { items: [] });\r\n}\r\n","title":"Get Student Result","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aec5807f941ca2264648083"},"code":"this.args.entity.domain = this.args.$user.domain;\nthis.debug(\"creating new assignment\");\nthis.debug(this.args);\nlet query = {\n  course: this.args.entity.courseId,\n  department: this.args.entity.department,\n  lecturer: this.args.entity.lecturer,\n  session: this.args.entity.session,\n  domain: this.args.$user.domain,\n  semester: this.args.entity.semester,\n  studentType: this.args.entity.studentType,\n  campus: this.args.entity.campus,\n  isHod: true\n};\nthis.debug(query);\n\nthis.entityRepo.get(\"CourseLecturerAssignment\", query, (error, exists) => {\n  if (error) return callback(error);\n  else if (exists.length)\n    return callback(new Error(\"An entry with that configuration already exists please edit the course to lecturer assignment\"));\n  else this.entityRepo.create(\"CourseLecturerAssignment\", query, callback);\n});\n","title":"Assign Course to HOD","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aec5a84f941ca2264648086"},"code":"this.entityRepo.infrastructure().userManager.getRoles({ name: this.args.$domain.config[\"hodRole\"] }, (error, role) => {\n  if (error || (role && role.length <= 0)) callback(new Error(\"There is a config error. Role could not be found\"));\n\n  if (role instanceof Array) role = role[0];\n\n  this.entityRepo.infrastructure().userManager.getUsersByParam({ roles: role._id }, (error, users) => {\n    if (error || (users && users.length <= 0)) {\n      callback(new Error(\"Lecturers have not been setup\"));\n    } else {\n      users = users.map(user => user._id);\n      this.entityRepo.get(\"Staff\", { userId: { $in: users } }, (error, staffs) => {\n        if (error || (staffs && staffs.length <= 0)) {\n          callback(new Error(\"Could not find the staff profiles. Ensure that the hods have successfully been registered as staffs\"));\n        } else {\n          staffs = staffs.map(staff => {\n            return {\n              _id: staff._id,\n              displayLabel: staff.fullName\n            };\n          });\n          return callback(null, staffs);\n        }\n      });\n    }\n  });\n});\n","title":"Get HODS","requiresIdentity":true,"standalone":true,"__v":0}]

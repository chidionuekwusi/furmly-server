[{"_id":{"$objectID":"5ae6f5aeed96bc603898dc96"},"code":"this.args.entity.domain = this.args.$domain._id || this.args.$user.domain;\nthis.debug(\"creating new assignment\");\nthis.debug(this.args);\n\nthis.entityRepo.get(\"Staff\", { userId: this.args.$user._id, domain: this.args.entity.domain }, { one: true }, (error, staff) => {\n  if (error || !staff) callback(new Error(\"You need to be a staff in this domain to perform this transaction\"));\n  else {\n    let query = {\n      course: this.args.entity.courseId,\n      domain: this.args.$user.domain,\n      campus: this.args.entity.campus,\n      courseAssignmentId: this.args.entity._id\n    };\n    this.debug(query);\n\n    this.entityRepo.get(\"CourseLecturerAssignment\", query, (error, exists) => {\n      if (error) return callback(error);\n      else if (exists.length) {\n        this.entityRepo.update(\n          \"CourseLecturerAssignment\",\n          {\n            _id: exists[0]._id,\n            lecturer: this.args.entity.lecturer\n          },\n          callback\n        );\n      } else {\n        query[\"lecturer\"] = this.args.entity.lecturer;\n        this.entityRepo.create(\"CourseLecturerAssignment\", query, callback);\n      }\n    });\n  }\n});\n","title":"Assign course to lecturer","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5ae7165ded96bc603898dc9b"},"code":"this.args.depth = true;\r\nthis.$checkDomain = true;\r\nconst objectId = prop => {\r\n  if (this.args.query && this.args.query[prop])\r\n    this.args.query[prop] = {\r\n      isObjectID: true,\r\n      value: this.args.query[prop]\r\n    };\r\n};\r\nthis.debug(\"the isHod is: \" + this.args.isHod);\r\nconst run = {\r\n  extended: () => {\r\n    if (!this.args.query || !this.args.query.studentType)\r\n      return callback(null, {\r\n        items: [],\r\n        total: 0\r\n      });\r\n\r\n    this.debug(this.args);\r\n\r\n    let extra = {\r\n      department: this.args.query.department,\r\n      semester: this.args.query.semester,\r\n      session: this.args.query.session,\r\n      studentType: this.args.query.studentType,\r\n      campus: this.args.query.campus\r\n    };\r\n\r\n    if (this.args.query && this.args.query.campus) delete this.args.query.campus;\r\n\r\n    this.debug(this.args.query);\r\n\r\n    this.entityRepo.get(\"Staff\", { userId: this.args.$user._id, domain: this.args.$domain._id }, { one: true }, (error, staff) => {\r\n      if (error || !staff) callback(new Error(\"You have to be a staff in this domain to perform this action\"));\r\n      else {\r\n        this.entityRepo.aggregate(\r\n          \"CourseAssignment\",\r\n          [\r\n            {\r\n              $match: {\r\n                department: {\r\n                  $objectID: this.args.query.department\r\n                },\r\n                semester: {\r\n                  $objectID: this.args.query.semester\r\n                },\r\n                session: {\r\n                  $objectID: this.args.query.session\r\n                },\r\n                studentType: {\r\n                  $objectID: this.args.query.studentType\r\n                },\r\n                domain: {\r\n                  $objectID: this.args.$domain._id\r\n                }\r\n              }\r\n            },\r\n            {\r\n              $lookup: {\r\n                from: this.entityRepo.getCollectionName(\"CourseType\"),\r\n                localField: \"courseType\",\r\n                foreignField: \"_id\",\r\n                as: \"_courseType\"\r\n              }\r\n            },\r\n            {\r\n              $unwind: {\r\n                path: \"$_courseType\",\r\n                preserveNullAndEmptyArrays: true\r\n              }\r\n            },\r\n            {\r\n              $lookup: {\r\n                from: this.entityRepo.getCollectionName(\"Course\"),\r\n                localField: \"course\",\r\n                foreignField: \"_id\",\r\n                as: \"_course\"\r\n              }\r\n            },\r\n            {\r\n              $unwind: {\r\n                path: \"$_course\",\r\n                preserveNullAndEmptyArrays: true\r\n              }\r\n            },\r\n            {\r\n              $lookup: {\r\n                from: this.entityRepo.getCollectionName(\"CourseLecturerAssignment\"),\r\n                localField: \"_id\",\r\n                foreignField: \"courseAssignmentId\",\r\n                as: \"_lecturerAssignment\"\r\n              }\r\n            },\r\n            // {\r\n            //   $match: {\r\n            //     \"_lecturerAssignment.lecturer\": staff._id\r\n            //   }\r\n            // },\r\n            {\r\n              $unwind: {\r\n                path: \"$_lecturerAssignment\",\r\n                preserveNullAndEmptyArrays: true\r\n              }\r\n            },\r\n            {\r\n              $project: {\r\n                _id: 1,\r\n                courseType: \"$_courseType.name\",\r\n                courseName: \"$_course.name\",\r\n                courseUnit: 1,\r\n                courseCode: \"$_course.code\",\r\n                courseId: \"$_course._id\",\r\n                lecturer: \"$_lecturerAssignment.lecturer\",\r\n                hod: \"$_lecturerAssignment.hod\",\r\n                courseLecturerAssignmentId: \"$_lecturerAssignment._id\"\r\n              }\r\n            },\r\n            {\r\n              $sort: {\r\n                _id: -1\r\n              }\r\n            },\r\n            {\r\n              $limit: this.args.count\r\n            }\r\n          ],\r\n          (error, assignments) => {\r\n            this.debug(assignments);\r\n            if (error || (assignments && assignments.length < 1)) callback(new Error(\"Could not find course assignment for the criteria\"));\r\n            else {\r\n              for (let i = 0; i < assignments.length; i++) {\r\n                assignments[i] = Object.assign(\r\n                  {\r\n                    assigned:\r\n                      !assignments[i].lecturer && !assignments[i].hod\r\n                        ? \"Not Assigned\"\r\n                        : assignments[i].lecturer && !assignments[i].hod ? \"Not Assigned to HOD\" : \"Assigned\"\r\n                  },\r\n                  extra,\r\n                  assignments[i]\r\n                );\r\n              }\r\n              callback(null, { items: assignments, total: assignments.length });\r\n            }\r\n          }\r\n        );\r\n      }\r\n    });\r\n  },\r\n  stripped: () => {\r\n    if (!this.args.query)\r\n      return callback(null, {\r\n        items: [],\r\n        total: 0\r\n      });\r\n\r\n    this.entityRepo.get(\r\n      \"Staff\",\r\n      {\r\n        userId: this.args.$user._id,\r\n        domain: this.args.$domain._id\r\n      },\r\n      {\r\n        one: true\r\n      },\r\n      (er, staff) => {\r\n        if (er) return callback(er);\r\n        if (!staff) return callback(new Error(\"You have to be a staff to perform this operation\"));\r\n        else {\r\n          this.args.query.department = staff.department.toString();\r\n          this.args.query.lecturer = staff._id.toString();\r\n          let extra = {\r\n            semester: this.args.query.semester,\r\n            session: this.args.query.session,\r\n            department: this.args.query.department\r\n          };\r\n\r\n          this.debug(this.args.query);\r\n\r\n          this.entityRepo.aggregate(\r\n            \"CourseAssignment\",\r\n            [\r\n              {\r\n                $match: {\r\n                  department: {\r\n                    $objectID: this.args.query.department\r\n                  },\r\n                  semester: {\r\n                    $objectID: this.args.query.semester\r\n                  },\r\n                  session: {\r\n                    $objectID: this.args.query.session\r\n                  },\r\n                  domain: {\r\n                    $objectID: this.args.$domain._id\r\n                  }\r\n                }\r\n              },\r\n              {\r\n                $lookup: {\r\n                  from: this.entityRepo.getCollectionName(\"Course\"),\r\n                  localField: \"course\",\r\n                  foreignField: \"_id\",\r\n                  as: \"_course\"\r\n                }\r\n              },\r\n              {\r\n                $unwind: {\r\n                  path: \"$_course\",\r\n                  preserveNullAndEmptyArrays: true\r\n                }\r\n              },\r\n              {\r\n                $lookup: {\r\n                  from: this.entityRepo.getCollectionName(\"CourseLecturerAssignment\"),\r\n                  localField: \"_id\",\r\n                  foreignField: \"courseAssignmentId\",\r\n                  as: \"_lecturerAssignment\"\r\n                }\r\n              },\r\n              {\r\n                $match: {\r\n                  \"_lecturerAssignment.lecturer\": {\r\n                    $objectID: this.args.query.lecturer\r\n                  }\r\n                }\r\n              },\r\n              {\r\n                $unwind: {\r\n                  path: \"$_lecturerAssignment\",\r\n                  preserveNullAndEmptyArrays: true\r\n                }\r\n              },\r\n              {\r\n                $project: {\r\n                  _id: 1,\r\n                  courseName: \"$_course.name\",\r\n                  courseUnit: 1,\r\n                  courseCode: \"$_course.code\",\r\n                  courseId: \"$_course._id\",\r\n                  lecturer: \"$_lecturerAssignment.lecturer\",\r\n                  courseLecturerAssignmentId: \"$_lecturerAssignment._id\"\r\n                }\r\n              },\r\n              {\r\n                $sort: {\r\n                  _id: -1\r\n                }\r\n              },\r\n              {\r\n                $limit: this.args.count\r\n              }\r\n            ],\r\n            (error, assignments) => {\r\n              this.debug(assignments);\r\n              if (error || (assignments && assignments.length < 1))\r\n                callback(new Error(\"Could not find course assignment for the criteria\"));\r\n              else {\r\n                for (let i = 0; i < assignments.length; i++) {\r\n                  assignments[i] = Object.assign({}, extra, assignments[i]);\r\n                }\r\n                callback(null, { items: assignments, total: assignments.length });\r\n              }\r\n            }\r\n          );\r\n        }\r\n      }\r\n    );\r\n  }\r\n};\r\n\r\nif (this.args.query && this.args.query.department) run.extended();\r\nelse run.stripped();\r\n","title":"Get Course Lecturer assignment","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aeae84ab8ff605b883f098b"},"code":"let inf = this.entityRepo.infrastructure(),\n  fileUpload = inf.fileUpload,\n  fileParser = inf.fileParser,\n  threadPool = inf.threadPool;\nthis.debug(\"=============================================================\");\nthis.debug(this.args);\nthis.libs.parseObjectIds.call(this, this.args);\n\nlet uploadResult = () => {\n  this.entityRepo.get(\"Staff\", { userId: this.args.$user._id, domain: this.args.$domain._id }, { one: true }, (error, staff) => {\n    if (error || !staff) callback(new Error(\"No staff details could be found\"));\n\n    let args = this.args.entity,\n      contx = {\n        semester: args.semester,\n        session: args.session,\n        department: args.department,\n        course: args.courseId,\n        lecturer: staff._id,\n        courseAssignmentId: args._id\n      };\n    this.libs.convertFileAndSave(\n      this.args.$domain.config.resultClass,\n      args.file,\n      contx,\n      [\"regNo\", \"fullName\", \"examScore\", \"courseCode\", \"examDate\"],\n      null,\n      fileUpload,\n      fileParser,\n      threadPool,\n      this.entityRepo,\n      this.args.$user,\n      (error, result) => {\n        if (error) callback(error);\n        else callback(null, { items: [], message: \"Results were successfully uploaded\" });\n      }\n    );\n  });\n};\n\nif (!fileUpload || !fileParser || !threadPool) {\n  this.debug(`something is undefined ...fileUpload:${!!fileUpload}, fileParser:${!!fileParser}, threadPool:${!!threadPool}`),\n    callback(new Error(\"Infrastructure has a problem\"));\n} else if (!this.args.entity && !this.args.entity.file) {\n  this.debug(\"user didnt upload any file\");\n  callback(new Error(\"Missing Result file. Try uploading the file again, if this was already done.\"));\n} else uploadResult();\n","title":"upload student results","uid":"UPLOAD_STUDENT_RESULT","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aec5807f941ca2264648083"},"code":"this.args.entity.domain = this.args.$domain._id || this.args.$user.domain;\nthis.debug(\"creating new assignment\");\nthis.debug(this.args);\n\nthis.entityRepo.get(\"Staff\", { userId: this.args.$user._id, domain: this.args.entity.domain }, { one: true }, (error, staff) => {\n  if (error || !staff) callback(new Error(\"You need to be a staff in this domain to perform this transaction\"));\n  else {\n    let query = {\n      course: this.args.entity.courseId,\n      domain: this.args.$user.domain,\n      campus: this.args.entity.campus,\n      courseAssignmentId: this.args.entity._id\n    };\n    this.debug(query);\n\n    this.entityRepo.get(\"CourseLecturerAssignment\", query, (error, exists) => {\n      if (error) return callback(error);\n      else if (exists.length) {\n        this.entityRepo.update(\n          \"CourseLecturerAssignment\",\n          {\n            _id: exists[0]._id,\n            hod: this.args.entity.hod\n          },\n          (error, result) => {\n            if (error) callback(new Error(\"An error occurred while updating the assignment\"));\n            else callback(null, { items: [], message: \"The assignment was successfully updated\" });\n          }\n        );\n      } else {\n        query[\"lecturer\"] = this.args.entity.hod;\n        query[\"hod\"] = this.args.entity.hod;\n        this.entityRepo.create(\"CourseLecturerAssignment\", query, (error, result) => {\n          if (error) callback(new Error(\"An error occurred while trying to create the assignment\"));\n          else callback(null, { items: [], message: \"The assignment was successfully created\" });\n        });\n      }\n    });\n  }\n});\n","title":"Assign Course to HOD","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aec5928f941ca2264648085"},"code":"this.args.isHod = true;\nsetImmediate(callback, null, this.args);","title":"prepare for course to hod assignment","requiresIdentity":true,"standalone":true,"__v":0},{"_id":{"$objectID":"5aec75fabebc0b490c108b8f"},"code":"this.entityRepo.get(\"Staff\", { userId: this.args.$user._id, domain: this.args.$domain._id }, { one: true }, (error, staff) => {\n  if (error) callback(new Error(\"User is not a staff\"));\n  else {\n    this.entityRepo.infrastructure().userManager.getUserById(this.args.$user._id, (error, user) => {\n      let isHod = this.entityRepo.infrastructure().userManager.inRole(this.args.$domain.config.hodRole, user);\n      if (isHod) {\n        this.debug(\"the current args entity is =========\");\n        this.debug(this.args.entity);\n        this.entityRepo.get(\n          \"CourseLecturerAssignment\",\n          { courseAssignmentId: this.args.entity._id, hod: staff._id },\n          { one: true },\n          (error, lecturerAssignment) => {\n            this.debug(lecturerAssignment.hod);\n            this.debug(staff._id);\n            if (error || !lecturerAssignment) callback(new Error(\"You are not the HOD assigned to this course\"));\n            else {\n              this.entityRepo.update(\n                this.args.$domain.config.resultClass,\n                Object.assign(\n                  {\n                    $query: {\n                      courseAssignmentId: this.args.entity._id,\n                      course: this.args.entity.courseId,\n                      session: this.args.entity.session,\n                      semester: this.args.entity.semester\n                    }\n                  },\n                  { $update: { approved: this.args.entity.approved } }\n                ),\n                (error, result) => {\n                  if (error || !result) callback(error || new Error(\"No result found\"));\n                  else callback(null, { items: [], message: \"Result has been approved\" });\n                }\n              );\n            }\n          }\n        );\n      } else {\n        callback(new Error(\"You have to be an HOD to approve this\"));\n      }\n    });\n  }\n});\n","title":"approve result","requiresIdentity":true,"standalone":true,"__v":0}]

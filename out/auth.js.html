<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: auth.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: auth.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var jwt = require('jsonwebtoken'),
	bcrypt = require('bcrypt'),
	utils = require('util'),
	crypto = require('crypto');

/**
 * Function for transforming query result
 * @param  {Function} fn callback
 * @param  {Object}   er Error
 * @param  {Object}   x  Result to transform
 * @return {Object}      Transformed result
 */
function transformAndSend(fn, er, x) {
	if (er) return fn(er);
	if (x) {
		if (x instanceof Array) {
			x = x.map(this.transform);
		} else {
			x = this.transform(x);
		}
	}
	return fn(null, x);
}

/**
 * Used to generate random base64 string
 * @param  {Number} len Length of string to generate
 * @return {String}     Random String
 */
function randomValueBase64(len) {
	return crypto.randomBytes(Math.ceil(len * 3 / 4))
		.toString('base64') // convert to base64 format
		.slice(0, len) // return required number of characters
		.replace(/\+/g, '0') // replace '+' with '0'
		.replace(/\//g, '0'); // replace '/' with '0'
}

/**
 * Generates a salt and encrypts plaintext using bcrypt
 * @param  {String}   plainText plainText to encrypt
 * @param  {Function} cb        callback
 * @return {String}             Cipher Text (encryted string)
 */
function encrypt(plainText, cb) {
	bcrypt.genSalt(10, function(err, salt) {
		if (err) {
			cb(err);
		}
		bcrypt.hash(plainText, salt, function(err, hash) {
			cb(err, hash);
		});
	});
}

/**
 * User class
 * @param {Object} opts User information.
 */
function User(opts) {
	if (!opts)
		throw new Error('User needs username and roles');

	if (!opts.username)
		throw new Error('Users must have a username');

	if (!opts.roles || !opts.roles.length)
		throw new Error('Users must have atleast one role');

	this.username = opts.username;
	this.roles = opts.roles;
	this.domain = opts.domain;
	this.claims = opts.claims;
	Object.defineProperties(this, {
		'password': {
			enumerable: false,
			get: function() {
				return opts.password;
			}
		}
	});
}

/**
 * Returns storable information about the student
 * @param  {Boolean} includePassword flag , if true includes students password in output
 * @return {Object}                 Persistable representation of User.
 */
User.prototype.getImage = function(includePassword) {
	var image = JSON.parse(JSON.stringify(this));
	if (includePassword)
		image.password = this.password;
	return image;
};

/**
 * User role calss
 * @param {Object} opts configuration object , which includes claims and name (name is compulsory).
 */
function Role(opts) {

	if (!opts)
		throw new Error('Role configuration opts missing');
	if (!opts.name)
		throw new Error('Every role requires a name');

	this.claims = opts.claims || [];
	this.name = opts.name;
}

/**
 * This is the interface that systems outside the domain can interact with.
 * @param {Object} opts Configuration object.(userStore,roleStore,claimsStore and tokenGen are compulsory)
 */
function UserManager(opts) {
	if (!opts)
		throw new Error('UserManager configuration opts missing');
	if (!opts.userStore)
		throw new Error('UserManager must have a user store');

	if (!opts.roleStore)
		throw new Error('UserManager requires a role store');

	if (!opts.claimsStore)
		throw new Error('UserManager requires a claims store');

	if (!opts.tokenGen)
		throw new Error('UserManager requires a token generation strategy');

	if (!opts.menuStore)
		throw new Error('UserManager requires a menu store');

	this.userStore = opts.userStore;
	this.claimsStore = opts.claimsStore;
	this.roleStore = opts.roleStore;
	this.tokenGen = opts.tokenGen;
	this.menuStore = opts.menuStore;
}

/**
 * Login user using password.
 * @param  {String}   client   client making the request on the users behalf
 * @param  {String}   username username 
 * @param  {String}   password the user's password
 * @param  {Function} fn       callback
 * @return {Object}            returns access_token,refresh_token and expiry date of access_token
 */
UserManager.prototype.login = function(domain, client, username, password, fn) {
	var self = this;
	this.userStore.getUser(username, domain, function(er, user) {
		if (er) return fn(er);

		if (!user) return fn(new Error('Invalid Credentials'));

		bcrypt.compare(password, user.password, function(er, res) {

			if (er) return fn(er);

			if (!res) return fn(new Error('Invalid Credentials'));

			var expTime = Math.floor(Date.now() / 1000) + (60 * 60);
			var accessToken = self.tokenGen.sign(user, expTime);
			var refreshToken = randomValueBase64(128);
			var refreshTokenHash = crypto.createHash('sha1').update(refreshToken).digest('hex');
			self.userStore.createRefreshToken(refreshTokenHash, username, client.clientId, domain, function(er, result) {
				fn(null, accessToken, refreshToken, {
					expires_in: new Date(expTime)
				});
			});

		});
	});
};


/**
 * Registers a new user
 * @param  {Object}   data user info, which includes username ,password and role
 * @param  {Function} fn   callback
 * @return {Object}        Created User.
 */
UserManager.prototype.register = function(data, fn) {
	var self = this;
	this.userStore.exists(data.username, data.domain, function(er, exists) {
		if (er) return fn(er);
		if (exists) return fn(new Error('user already exists'));
		encrypt(data.password, function(er, hash) {
			if (er) return fn(er);
			data.password = hash;
			self.userStore.save(data, true, fn);
		});

	});
};

/**
 * Creates a new role
 * @param  {Object}   data role information
 * @param  {Function} fn   callback
 * @return {Object}        Created Role
 */
UserManager.prototype.createRole = function(data, fn) {
	var self = this;
	this.roleStore.getRole(data.name, data.domain, function(er, exists) {
		if (er) return fn(er);
		if (exists) return fn(new Error('role already exists'));
		self.roleStore.save(data, fn);
	});
};

/**
 * Verifies an accesstoken was issued by this service
 * @param  {String}   accessToken Access token to verify
 * @param  {Function} fn          callback
 * @return {Object}               result of verification. (varies depending on implementation of tokenGen).
 */
UserManager.prototype.verify = function(accessToken, fn) {
	try {
		var result = this.tokenGen.verify(accessToken);
		fn(null, result);
	} catch (e) {
		fn(e);
	}
};

/**
 * Access control list (menu items)
 * @param  {String}   username Username
 * @param  {String}   domain   User's domain (Blank for global domain)
 * @param  {Function} fn       Callback
 * @return {Array}            List of Menus that match the search criteria.
 */
UserManager.prototype.acl = function(username, domain, client, fn) {
	this.userStore.getUser(username, function(er, user) {
		if (er) return fn(er);
		if (!user) return fn(new Error('Could not find Items'));

		var claims = user.roles.reduce(function(z, b) {
			return z.concat(b.claims);
		}, user.claims || []);

		self.menuStore.getMenus({
			client: {
				$or: [null, client]
			},
			domain: domain,
			claims: {
				$in: claims
			}
		}, fn);
	});

};

/**
 * Passthrough method for claimsStore.getClaims
 * @param  {Object}   query Search Criteria
 * @param  {Function} fn    Callback
 * @return {Array}         Result.
 */
UserManager.prototype.getClaims = function(query, fn) {
	this.claimsStore.getClaims(query, fn);
};

/**
 * Passthrough method for claimsStore.saveClaim
 * @param  {Object}   data claim to save (type &amp; value)
 * @param  {Function} fn    Callback
 * @return {Object}         Saved Object.
 */
UserManager.prototype.saveClaim = function(data, fn) {
	this.claimsStore.save(data, fn);
};
/**
 * Passthrough method for menuStore.saveMenu
 * @param  {Object}   data menu to save
 * @param  {Function} fn    Callback
 * @return {Object}         Saved Object.
 */
UserManager.prototype.saveMenu = function(data, fn) {
	this.menuStore.save(data, fn);
};
/**
 * Passthrough method for menuStore.getMenus
 * @param  {Object}   query Search Criteria
 * @param  {Function} fn    Callback
 * @return {Array}         Result.
 */
UserManager.prototype.getMenus = function(query, fn) {
	this.menuStore.getMenus(query, fn);
};

/**
 * TokenGenerator Class. Responsible for creating accesstokens.
 * @param {Object} opts configuration object.
 */
function TokenGenerator(opts) {
	if (!opts)
		throw new Error('Auth configuration opts missing');

	if (!opts.issuer)
		throw new Error('Auth service must have an issuer');

	if (!opts.secret)
		throw new Error('Auth service must have a secret');

	if (!opts.audience)
		throw new Error('Auth service must have an audience');


	this.audience = opts.audience;
	this.secret = opts.secret;
	this.issuer = opts.issuer;
}

/**
 * Creates an accesstoken
 * @param  {Object} data information to sign
 * @param  {Number} exp  Time to live
 * @return {String}      Signed accesstoken
 */
TokenGenerator.prototype.sign = function(data, exp) {
	//sign the token and return it.
	return jwt.sign({
		exp: exp,
		data: data
	}, this.secret, {
		audience: this.audience,
		issuer: this.issuer
	});
};

/**
 * Verifies an accesstoken
 * @param  {String}   token token to verify
 * @param  {Function} fn    callback
 * @return {Object}         original data if successful, null if not.
 */
TokenGenerator.prototype.verify = function(token, fn) {
	return jwt.verify(token, this.secret, {
		audience: this.audience,
		issuer: this.issuer
	});
};

/**
 * User Store Class. Uses mongoose for persistence.
 * @param {Object} mongoose Connected mongoose client.
 */
function MongoDBUserStore(mongoose, conn) {
	if (!mongoose || !conn)
		throw new Error('user store requires an open mongoose connection');

	var Schema = mongoose.Schema;

	var userSchema = new Schema({
		username: String,
		password: String,
		domain: String,
		roles: [{
			type: Schema.Types.ObjectId,
			ref: 'Role'
		}],
		claims: [{
			type: Schema.Types.ObjectId,
			ref: 'Claim'
		}]
	});
	this.connection = conn;
	this.transform = function(user) {
		return new User(user);
	};
	this.model = conn.model('User', userSchema);
}


/**
 * Stores a refreshtoken
 * @param  {String}   refreshTokenHash Refresh token
 * @param  {String}   clientId         Client ID
 * @param  {String}   username         Username
 * @param  {Function} fn               callback
 * @return {Object}                    newly created refreshtoken
 */
MongoDBUserStore.prototype.createRefreshToken = function(refreshTokenHash, clientId, username, domain, fn) {
	this.connection.db.collection('refreshTokens').insertOne({
		refreshToken: refreshTokenHash,
		clientId: clientId,
		domain: domain,
		userId: username
	}, fn);
};

/**
 * Returns a refresh token.
 * @param  {String}   refreshTokenHash tokenHash
 * @param  {String}   clientId         Client ID token was issued to
 * @param  {String}   username         Username token was issued to.
 * @param  {Function} fn               Callback
 * @return {Object}                    RefreshToken
 */
MongoDBUserStore.prototype.getRefreshToken = function(refreshTokenHash, clientId, username, domain, fn) {
	this.connection.db.collection('refreshTokens').findOne({
		refreshToken: refreshTokenHash,
		clientId: clientId,
		domain: domain,
		userId: username
	}, fn);
};

/**
 * Saves a User
 * @param  {Object}   data            User to save
 * @param  {Boolean}   includePassword Include password hash in output
 * @param  {Function} fn              Callback
 * @return {Object}                   saved user
 */
MongoDBUserStore.prototype.save = function(data, includePassword, fn) {
	if (!(data instanceof User)) {
		try {
			data = this.transform(data);
		} catch (e) {
			fn(e);
			return;
		}
	}
	new this.model(data.getImage(includePassword)).save(fn);
};

/**
 * Returns all user details
 * @param  {String}   username username
 * @param  {Function} fn       Callback
 * @return {Object}            User
 */
MongoDBUserStore.prototype.getUser = function(username, domain, fn) {
	if (Array.prototype.slice.call(arguments).length == 2) {
		fn = domain;
		domain = null;
	}

	var query = {
		username: username,
		domain: domain
	};

	this.model.findOne(query).populate('claims').populate('roles').populate({
		path: 'roles',
		populate: {
			path: 'claims'
		}
	}).exec(transformAndSend.bind(this, fn));
};

/**
 * Queries for user.
 * @param  {Object}   query Object query
 * @param  {Function} fn    Callback
 * @return {Array}         List of users that match the query.
 */
MongoDBUserStore.prototype.getUsers = function(query, fn) {
	this.model.find(query, this.transformAndSend.bind(this, fn));
};

/**
 * Checks if user exists
 * @param  {String}   username Username
 * @param  {Function} fn       Callback
 * @return {Boolean}            indicates if user exists.
 */
MongoDBUserStore.prototype.exists = function(username, domain, fn) {
	this.model.findOne({
		username: username,
		domain: domain
	}, function(er, user) {
		if (er) return fn(er);
		return fn(null, !!user);
	});
};

/**
 * Role Store class. Keeps roles
 * @param {Object} mongoose Connected mongoose client.
 */
function MongoDBRoleStore(mongoose, conn) {
	if (!mongoose || !conn)
		throw new Error('role store requires an open mongoose connection');
	var Schema = mongoose.Schema;

	var roleSchema = new Schema({
		name: String,
		domain: String,
		claims: [{
			type: Schema.Types.ObjectId,
			ref: 'Claim'
		}]
	});
	this.model = conn.model('Role', roleSchema);
	this.transform = function(role) {
		return new Role(role);
	};
}

/**
 * Returns all the details of a role
 * @param  {String}   name Name of the role
 * @param  {Function} fn   Callback
 * @return {Object}        Role
 */
MongoDBRoleStore.prototype.getRole = function(name, domain, fn) {
	this.model.findOne({
		name: name,
		domain: domain
	}).populate('claims').exec(transformAndSend.bind(this, fn));
};
/**
 * Returns all roles that match search criteria
 * @param  {Object}   query Search Criteria
 * @param  {Function} fn    Callback
 * @return {Array}         List of objects that match search criteria
 */
MongoDBRoleStore.prototype.getRoles = function(query, fn) {
	this.model.find(query).exec(transformAndSend.bind(this, fn));
};

/**
 * Creates or updates a role
 * @param  {Object}   data role info
 * @param  {Function} fn   Callback
 * @return {Object}        Saved role
 */
MongoDBRoleStore.prototype.save = function(data, fn) {
	if (!(data instanceof Role)) {
		try {
			data = this.transform(data);
		} catch (e) {
			fn(e);
			return;
		}
	}
	new this.model(data).save(fn);
};
/**
 * ClaimsStore class. Responsible for storing claims. Uses mongoose.
 * @param {Object} mongoose Connected mongoose client.
 */
function MongoClaimsStore(mongoose, conn) {
	if (!mongoose || !conn)
		throw new Error('claims store requires an open mongoose connection');
	var Schema = mongoose.Schema;

	var claimSchema = new Schema({
		type: String,
		value: String
	});
	this.model = conn.model('Claim', claimSchema);
}
/**
 * Stores a new claim
 * @param  {Object}   claim Claim info (type and value)
 * @param  {Function} fn    Callback
 * @return {Object}         Object representing saved claim
 */
MongoClaimsStore.prototype.save = function(claim, fn) {
	new this.model(claim).save(fn);
};

/**
 * Returns list of claims matching the search criteria
 * @param  {Object}   query Search Criteria
 * @param  {Function} fn    Callback
 * @return {Object}         List of claims matching search criteria
 */
MongoClaimsStore.prototype.getClaims = function(query, fn) {
	this.model.find(query, fn);
};


/**
 * Menu item to be displayed by both the mobile and website.
 * @param {Object} opts Configuration object.
 */
function Menu(opts) {

	if (!opts)
		throw new Error('Menu item is missing configuration');

	if (!opts.displayLabel &amp;&amp; !opts.icon)
		throw new Error('All menu items must either have a displayLabel or a display icon');

	if (!opts.type)
		throw new Error('All menu items require a valid type');

	if (!opts.value)
		throw new Error('All menu items must have a category');

	this.icon = opts.icon;
	this.displayLabel = opts.displayLabel;
	this.claims = opts.claims || [];
	this.type = opts.type;
	this.value = opts.value;
	this.category = opts.category;
	this.client = opts.client;
	this.domain = opts.domain;
	this.group = opts.group;
}

/**
 * MenuStore for retrieving and Creating menu items.
 * @param {Object} mongoose Connected Mongoose Client.
 */
function MongoMenuStore(mongoose, conn) {
	if (!mongoose || !conn)
		throw new Error('mongoose is required by MongoMenuStore');

	var Schema = mongoose.Schema;

	var menuSchema = new Schema({
		displayLabel: String,
		icon: String,
		client: String,
		type: {
			type: String,
			enum: ["DYNAMO"]
		},
		domain: String,
		group: String,
		value: String,
		category: String,
		claims: [{
			type: Schema.Types.ObjectId,
			ref: 'Claim'
		}]
	});
	this.model = conn.model('Menu', menuSchema);
	this.transform = function(menu) {
		return new Menu(menu);
	};
}

/**
 * 
 * Create or update Menu Item
 * @param  {Object}   data Object or MenuItem class
 * @param  {Function} fn   Callback
 * @return {Object}        Saved object
 */
MongoMenuStore.prototype.save = function(data, fn) {
	if (!(data instanceof Menu)) {
		try {
			data = this.transform(data);
		} catch (e) {
			return fn(e);
		}
	}
	(new this.model(data)).save(transformAndSend.bind(this, fn));
};

/**
 * Returns a list of Menus that match the search criteria
 * @param  {Object}   query Search Criteria
 * @param  {Function} fn    Callback
 * @return {Array}         List of menus
 */
MongoMenuStore.prototype.getMenus = function(query, fn) {
	this.model.find(query).populate('claims').exec(transformAndSend.bind(this, fn));
};

module.exports = {
	TokenGenerator: TokenGenerator,
	UserStore: MongoDBUserStore,
	ClaimsStore: MongoClaimsStore,
	RoleStore: MongoDBRoleStore,
	UserManager: UserManager,
	MenuStore: MongoMenuStore
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#encrypt">encrypt</a></li><li><a href="global.html#Menu">Menu</a></li><li><a href="global.html#MongoClaimsStore">MongoClaimsStore</a></li><li><a href="global.html#MongoDBRoleStore">MongoDBRoleStore</a></li><li><a href="global.html#MongoDBUserStore">MongoDBUserStore</a></li><li><a href="global.html#MongoMenuStore">MongoMenuStore</a></li><li><a href="global.html#randomValueBase64">randomValueBase64</a></li><li><a href="global.html#Role">Role</a></li><li><a href="global.html#TokenGenerator">TokenGenerator</a></li><li><a href="global.html#transformAndSend">transformAndSend</a></li><li><a href="global.html#User">User</a></li><li><a href="global.html#UserManager">UserManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Jun 20 2017 18:17:46 GMT+0100 (W. Central Africa Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
